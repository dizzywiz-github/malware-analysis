#modules
import os
import sys
import argparse
import getpass
import configparser
import hashlib
import magic
import subprocess
import pefile
import re
import datetime
import yara
import math

print("[+] Logged in User: "+getpass.getuser())
#---------------------

#get file 
file_name=sys.argv[1]
print("[+] File Name: ", file_name)

file_type=magic.from_file(file_name, mime = True)
print("[+] File Type: ", file_type)
#---------------------

def get_file_entropy(file_name): 
	with open(file_name, 'rb') as f:
        	data = f.read()

	frequency = {}
	for b in data:
		if b in frequency:
			frequency[b] += 1
		else:
			frequency[b] = 1
	entropy = 0
	for b in frequency:
		p = frequency[b] / len(data)
		entropy -= p * math.log2(p)
	return entropy

entropy = get_file_entropy(file_name)
print('[+] File entropy: ', entropy)
#---------------------

#file hash
with open(file_name,"rb") as f:
    bytes=f.read()
    md_5=hashlib.md5(bytes).hexdigest()
    sha_256=hashlib.sha256(bytes).hexdigest()
    sha_512=hashlib.sha512(bytes).hexdigest()
    print("[+] File Hash")
    print('\t[-] MD5: ', md_5)
    print('\t[-] SHA256: ', sha_256)
    print('\t[-] SHA512: ', sha_512)
#---------------------

try:
	pe = pefile.PE(file_name)
	#print("[+] File size: ", pe.filesize)
	print("[+] EPOCH Timestamp: ", pe.FILE_HEADER.TimeDateStamp)

	def convert_epoch_time(epoch_time):
		return datetime.datetime.fromtimestamp(epoch_time).strftime('%Y-%m-%d %H:%M:%S')

	epoch_time =  pe.FILE_HEADER.TimeDateStamp
	readable_time = convert_epoch_time(epoch_time)
	print("\t[-] ",f"Human readable timestamp: {readable_time}")


	# Print section information
	print("[+] Section information")
	for section in pe.sections:
		print("\t[-] Section Name: ", section.Name.decode().rstrip('\x00'))
		print("\t\t > Virtual Address: ", hex(section.VirtualAddress))
		print("\t\t > Size of Raw Data: ", section.SizeOfRawData)
except:
	print("[+] DOS header not found - Section Information not available for CODE, DATA, BSS, .idata, .rdata, .reloc, .rsrc ")
#---------------------

#get ASCII content and write in a file
mal_file=file_name
def read_strings(mal_file):
    result = subprocess.run(["strings", mal_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return result.stdout.decode("utf-8")

strings = read_strings(mal_file)
#print(strings)

content=open("ASCII_strings","w")
content.write(strings)
content.close()

#---------------------

file_path = 'ASCII_strings'
#---------------------

def extract_urls(file_path):
    with open(file_path, 'r') as file:
        text = file.read()
        urls = re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', text)
        return urls

urls = extract_urls(file_path)
#print(urls)
print("[+] URLs")
def print_urls(urls):
    for i, value in enumerate(urls, start=1):
        print("\t",f"{i}. {value}")

print_urls(urls)
#---------------------

def extract_ips(file_path):
    with open(file_path, 'r') as file:
        text = file.read()
        ips = re.findall('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', text)
        return ips

ips = extract_ips(file_path)
#print(ips)
print("[+] IPs")

def print_ips(ips):
    for i, value in enumerate(ips, start=1):
        print("\t",f"{i}. {value}")

print_ips(ips)
#---------------------

#list match
def matched_list(filepath, strings_to_match):
    count = {string: 0 for string in strings_to_match}
    try:
        with open(filepath, "r") as f:
            for line in f:
                for string in strings_to_match:
                    if string in line:
                        count[string] += 1
            return count
    except:
        return {}

# match counter
def print_list(filepath, strings_to_match):
    count = matched_list(filepath, strings_to_match)
    if len(count) > 0:
        for string, repetition_count in count.items():
            if repetition_count > 0:
                print("\t[-] ",f"{string}: {repetition_count}")
    else:
        print(f"No matches found in {filepath}.")


# basic calls
calls_list=["CreateMutex","CopyFile","CreateFile.*WRITE","NtasdfCreateFile","call shell32","advapi32.RegOpenKey","KERNEL32.CreateProcess","shdocvw","gethostbyname","ws2_32.bind","ws2_32.listen","ws2_32.htons","advapi32.RegCreate","advapi32.RegSet","Socket","OutputDebugString","GetEnvironmentStrings","LoadLibraryA","WSASocketA","GetProcAddress","FindWindow","CreateProcess","DuplicateTokenEx","signal","IdDebuggerPresent","STARTUPINFO()","GetLogicalDriveStrings()",".run([powershell code] stdout=subprocess.PIPE stderr=subprocess.STDOUT shell=True)","CommitSuicide()","RunAsAdmin()","IsPyExist()","os.path.join(root, file)"," th.start()"]


# dll calls
dll_list=["KERNEL.DLL","advapi32.dll","comctl32.dll","gdi32.dll","ole32.dll","oleaut32.dll","user32.dll","wsock32.dll","ntdll.dll","win32api","kernel32","shell32.dll"]

# system calls
system_calls_list=["ping.exe","telnet.exe","vmsrvc.exe" , "vmusrvc.exe", "vboxtray.exe", "vmtoolsd.exe", "df5serv.exe", "vboxservice.exe"]

# IRC
irc_list=["IRC","Joined Channel","Port","Bot","Login","flood","ddos","NICK","ECHO","ADMIN","CONNECT","PING","SERVICE","INFO","WHO","WHOIS","VERSION","requests.packages.urllib3.disable_warnings()",".com","192.168.202.1","4567","socket.socket(socket.AF_INET, socket.SOCK_STREAM)","client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)"," client.recv(2048)","socket.SO_REUSEADDR",]

# registry calls
reg_list=["HKEY_CURRENT_USER","HKEY_CLASSES_ROOT","HKEY_LOCAL_MACHINE","autorun.inf","REG ADD","REG_DWORD","DisableRegistryTools","DisableTaskMgr","DisableCMD","SintaRegistery","addRegistery"]

# crypto
crypt_list=["lstrcmpA","CryptGetUserKey","CryptExportKey","CryptDestoryKey","CryptReleaseContext","AES","Crypto","tool.encrypt(data)","Fernet","cryptography.fernet","base64","hazmat.backends","hazmat.primitives","PBKDF2HMAC","hashes.SHA256()","base64.urlsafe_b64encode(kdf.derive(password))","otp.decode()","secret.decode()","Fernet.generate_key()","0.0.0.0","4567"]

# spread
worm_list=["FindFirstFileA","lstrcmpiA","FindNextFileA","FindClose","text_generator"]

# location
location_list=["cipher /W:%s","CurrentVersion","Policies","HKEY_LOCAL_MACHINE","SYSTEM","Control","Terminal Server","c:/"]


print("[+] DLL Calls:")
print_list(file_path, dll_list)

print("[+] System Calls:")
print_list(file_path, system_calls_list)

print("[+] IRC Calls:")
print_list(file_path, irc_list)

print("[+] Registry Calls:")
print_list(file_path, reg_list)

print("[+] Crypto Calls:")
print_list(file_path, crypt_list)

print("[+] Spread Calls:")
print_list(file_path, worm_list)

print("[+] Location Calls:")
print_list(file_path, location_list)
#---------------------

#yara match
print("[+] Checking yara rule match")
def match_yara(file_path, yara_rules_file):
    with open(file_path, 'r') as f:
        text = f.read()
    with open(yara_rules_file, 'r') as f:
        yara_rules = f.read()
    rules = yara.compile(source=yara_rules)
    matches = rules.match(data=text)
    return matches

yara_rules_file = 'demo.yar'
matches = match_yara(file_path, yara_rules_file)
if matches:
    print(f"\t[-] Match found: {matches[0].rule}")
else:
    print("\t[-] No match found.")
#---------------------

print("\n\n **>> Check file ASCII_strings for all ASCII strings found in the file")

